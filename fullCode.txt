----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\main.cpp -----
#include <iostream>
#include "src/Chat/Chat.h"
#include "PlatformOSInfo/PlatformOSInfo.h"
#if defined(_WIN32)
#include <windows.h>
#endif
int main()
{
#if defined(_WIN32)
SetConsoleOutputCP(65001);
#endif
std::cout << "OS Info: " << getOSInfo() << std::endl;
std::cout << getProcessInfo() << std::endl;
try
{
ChatApp::Chat messenger("127.0.0.1", 8080);
messenger.Start();
while (messenger.ChatIsActive())
{
messenger.displayLoginMenu();
while (messenger.GetCurrentUser())
{
messenger.displayUserMenu();
}
}
}
catch (const std::exception &ex)
{
std::cerr << "Ошибка: " << ex.what() << std::endl;
return 1;
}
return 0;
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\networking\props.h -----
const unsigned short BUFFER_SIZE = 1024;
const unsigned short BUFFER_CELL = 10;
const unsigned short MAX_CLIENTS = 10;
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\networking\chatApp\ChatApp.h -----
#pragma once
#include <string>
#include <chrono>
#include <memory>
namespace ChatApp
{
class Chat;
class User;
class Message;
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\networking\client\Client.cpp -----
#include "Client.h"
#include "../props.h"
#include "../utils/messages.h"
#include "../../app/src/Chat/Chat.h"
#include "../../app/src/User/User.h"
#include <iostream>
#include <cstring>
#include <chrono>
#include <thread>
#include <memory>
#include <stdexcept>
namespace NetApp
{
Client::Client(const std::string &serverAddress, unsigned short serverPort, ChatApp::Chat *chat)
: serverAddress_(serverAddress), serverPort_(serverPort), clientSocket_(INVALID_SOCKET_VALUE),
connected_(false), receiving_(false), chatPtr_(chat)
{
}
Client::~Client()
{
disconnect();
}
bool Client::connectToServer()
{
clientSocket_ = socket(AF_INET, SOCK_STREAM, 0);
if (clientSocket_ == INVALID_SOCKET_VALUE)
{
throw std::runtime_error(clientMessages::CLIENT_SOCKET_ERROR);
}
sockaddr_in serverAddr;
std::memset(&serverAddr, 0, sizeof(serverAddr));
serverAddr.sin_family = AF_INET;
serverAddr.sin_port = htons(serverPort_);
if (inet_pton(AF_INET, serverAddress_.c_str(), &serverAddr.sin_addr) <= 0)
{
#if defined(_WIN32)
closesocket(clientSocket_);
#else
close(clientSocket_);
#endif
throw std::runtime_error(clientMessages::INVALID_ADDRESS);
}
if (connect(clientSocket_, reinterpret_cast<sockaddr *>(&serverAddr), sizeof(serverAddr)) < 0)
{
#if defined(_WIN32)
closesocket(clientSocket_);
#else
close(clientSocket_);
#endif
throw std::runtime_error(clientMessages::CONNECT_ERROR);
}
connected_ = true;
std::cout << clientMessages::CONNECT_SUCCESS
<< serverAddress_ << ":" << serverPort_
<< " успешно установлено." << std::endl;
return true;
}
void Client::disconnect()
{
if (connected_)
{
receiving_ = false;
if (receiveThread_.joinable())
{
receiveThread_.join();
}
#if defined(_WIN32)
closesocket(clientSocket_);
#else
close(clientSocket_);
#endif
clientSocket_ = INVALID_SOCKET_VALUE;
connected_ = false;
std::cout << clientMessages::DISCONNECT_SUCCESS << std::endl;
}
}
bool Client::sendMessage(const std::string &message)
{
if (!connected_)
throw std::runtime_error("Нет подключения к серверу");
int bytesSent = send(clientSocket_, message.c_str(), static_cast<int>(message.size()), 0);
if (bytesSent == SOCKET_ERROR_VALUE)
{
throw std::runtime_error(clientMessages::SEND_ERROR);
}
return true;
}
void Client::startReceiving()
{
if (!connected_)
return;
receiving_ = true;
receiveThread_ = std::thread(&Client::receiveLoop, this);
}
void Client::stopReceiving()
{
receiving_ = false;
if (receiveThread_.joinable())
{
receiveThread_.join();
}
}
void Client::receiveLoop()
{
char buffer[1024];
while (receiving_ && connected_)
{
std::memset(buffer, 0, sizeof(buffer));
int bytesReceived = ::recv(clientSocket_, buffer, sizeof(buffer) - 1, 0);
if (bytesReceived > 0)
{
std::string response(buffer);
handleServerResponse(response);
}
else if (bytesReceived == 0)
{
std::cout << "Сервер закрыл соединение\n";
disconnect();
return;
}
else
{
throw std::runtime_error("Ошибка получения данных");
}
}
disconnect();
}
bool Client::isConnected() const
{
return connected_;
}
void Client::handleServerResponse(const std::string &response)
{
std::istringstream iss(response);
std::string command;
std::getline(iss, command);
if (command == "LOGIN_OK")
{
std::string login;
std::getline(iss, login);
if (!login.empty())
{
chatPtr_->setCurrentUser(std::make_shared<ChatApp::User>(login, "", ""));
std::cout << "Вход успешен для " << login << std::endl;
}
}
else if (command == "SIGNUP_OK")
{
std::cout << "Регистрация успешна" << std::endl;
}
else if (command == "CHAT_MESSAGES")
{
std::string message;
while (std::getline(iss, message))
{
if (!message.empty())
{
std::istringstream msgStream(message);
std::string tsStr, from, to, text;
msgStream >> tsStr >> from >> to;
std::getline(msgStream, text);
std::time_t ts = std::stoll(tsStr);
std::tm *tm_info = std::localtime(&ts);
char buffer[80];
std::strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);
std::cout << "Время: " << buffer << " " << from << " -> " << to << ": " << text << std::endl;
}
}
}
else if (command == "USER_LIST")
{
std::string user;
while (std::getline(iss, user))
{
if (!user.empty())
{
std::cout << user << std::endl;
}
}
}
else if (command == "ERROR")
{
std::string errorMsg;
std::getline(iss, errorMsg);
if (!errorMsg.empty())
{
std::cerr << "Ошибка: " << errorMsg << std::endl;
}
}
else if (command == "OK")
{
std::string msg;
std::getline(iss, msg);
if (!msg.empty())
{
std::cout << "Успех: " << msg << std::endl;
}
}
else
{
std::cout << "Неизвестный ответ от сервера: " << response << std::endl;
}
}
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\networking\client\Client.h -----
#pragma once
#include <string>
#include <thread>
#include <atomic>
#include <memory>
#include "../chatApp/ChatApp.h"
#if defined(_WIN32)
#include <winsock2.h>
#include <ws2tcpip.h>
typedef SOCKET SocketType;
const SocketType INVALID_SOCKET_VALUE = INVALID_SOCKET;
const int SOCKET_ERROR_VALUE = SOCKET_ERROR;
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
typedef int SocketType;
const SocketType INVALID_SOCKET_VALUE = -1;
const int SOCKET_ERROR_VALUE = -1;
#endif
namespace NetApp
{
class Chat;
class Client
{
private:
std::string serverAddress_;
unsigned short serverPort_;
SocketType clientSocket_;
std::atomic<bool> connected_;
std::atomic<bool> receiving_;
std::thread receiveThread_;
ChatApp::Chat *chatPtr_;
public:
Client(const std::string &serverAddress, unsigned short serverPort, ChatApp::Chat *chat);
~Client();
bool connectToServer();
void disconnect();
bool sendMessage(const std::string &message);
void startReceiving();
void stopReceiving();
void receiveLoop();
bool isConnected() const;
void handleServerResponse(const std::string &response);
};
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\networking\netApp\NetApp.cpp -----
#include "NetApp.h"
#include "../../app/src/User/User.h"
#include "../../app/src/Message/Message.h"
#include <iostream>
#include <cstring>
#include <chrono>
#include <thread>
#include <memory>
#include <stdexcept>
#if defined(_WIN32)
#include <windows.h>
#include <winsock2.h>
#endif
namespace NetApp
{
#if defined(_WIN32)
struct WinsockInitializer
{
WinsockInitializer()
{
WSADATA wsaData;
if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
{
throw std::runtime_error("WSAStartup failed");
}
}
~WinsockInitializer()
{
WSACleanup();
}
} winsockInit;
#endif
Server::Server(unsigned short port)
: port_(port), serverSocket_(INVALID_SOCKET_VALUE), running_(false)
{
}
Server::~Server()
{
stop();
}
bool Server::start()
{
serverSocket_ = ::socket(AF_INET, SOCK_STREAM, 0);
if (serverSocket_ == INVALID_SOCKET_VALUE)
{
throw std::runtime_error("Ошибка создания сокета");
}
sockaddr_in serverAddr;
std::memset(&serverAddr, 0, sizeof(serverAddr));
serverAddr.sin_family = AF_INET;
serverAddr.sin_port = htons(port_);
serverAddr.sin_addr.s_addr = INADDR_ANY;
if (::bind(serverSocket_, reinterpret_cast<sockaddr *>(&serverAddr), sizeof(serverAddr)) == SOCKET_ERROR_VALUE)
{
#if defined(_WIN32)
::closesocket(serverSocket_);
#else
::close(serverSocket_);
#endif
throw std::runtime_error("Ошибка привязки сокета");
}
if (::listen(serverSocket_, SOMAXCONN) == SOCKET_ERROR_VALUE)
{
#if defined(_WIN32)
::closesocket(serverSocket_);
#else
::close(serverSocket_);
#endif
throw std::runtime_error("Ошибка прослушивания сокета");
}
running_ = true;
std::cout << "Сервер запущен на порту " << port_ << "\n";
clientThreads_.emplace_back(&Server::acceptClients, this);
return true;
}
void Server::stop()
{
if (!running_)
return;
running_ = false;
#if defined(_WIN32)
::closesocket(serverSocket_);
#else
::close(serverSocket_);
#endif
for (auto &t : clientThreads_)
{
if (t.joinable())
t.join();
}
clientThreads_.clear();
std::cout << "Сервер остановлен\n";
}
void Server::acceptClients()
{
while (running_)
{
sockaddr_in clientAddr;
socklen_t clientAddrSize = sizeof(clientAddr);
SocketType clientSocket = ::accept(serverSocket_, reinterpret_cast<sockaddr *>(&clientAddr), &clientAddrSize);
if (clientSocket == INVALID_SOCKET_VALUE)
{
if (!running_)
break;
throw std::runtime_error("Ошибка приема клиента");
}
std::cout << "Новый клиент подключился\n";
clientThreads_.emplace_back(&Server::handleClient, this, clientSocket);
}
}
void Server::handleClient(SocketType clientSocket)
{
char buffer[1024];
while (running_)
{
std::memset(buffer, 0, sizeof(buffer));
int bytesReceived = ::recv(clientSocket, buffer, sizeof(buffer) - 1, 0);
if (bytesReceived > 0)
{
std::string request(buffer);
std::string response = processRequest(clientSocket, request);
if (::send(clientSocket, response.c_str(), response.size(), 0) == SOCKET_ERROR_VALUE)
{
throw std::runtime_error("Ошибка отправки данных клиенту");
}
}
else if (bytesReceived == 0)
{
std::cout << "Клиент отключился\n";
handleDisconnect(clientSocket);
break;
}
else
{
throw std::runtime_error("Ошибка получения данных");
}
}
#if defined(_WIN32)
::closesocket(clientSocket);
#else
::close(clientSocket);
#endif
}
std::string Server::processRequest(SocketType clientSocket, const std::string &request)
{
std::lock_guard<std::mutex> lock(dataMutex_);
std::istringstream iss(request);
std::string command;
iss >> command;
if (command == "LOGIN")
{
std::string login, password;
iss >> login >> password;
if (usersByLogin_.count(login) && usersByLogin_[login]->GetUserPassword() == password)
{
clientToUser_[clientSocket] = login;
return "LOGIN_OK\n" + login;
}
return "ERROR\nInvalid login or password";
}
else if (command == "SIGNUP")
{
std::string login, password, name;
iss >> login >> password >> name;
if (usersByLogin_.count(login) || usersByName_.count(name))
{
return "ERROR\nUser already exists";
}
auto user = std::make_shared<ChatApp::User>(login, password, name);
usersByLogin_[login] = user;
usersByName_[name] = user;
return "SIGNUP_OK";
}
else if (command == "GET_CHAT")
{
std::string response = "CHAT_MESSAGES\n";
for (const auto &msg : messages_)
{
auto timestamp = std::chrono::system_clock::to_time_t(msg.GetTimestamp());
response += std::to_string(timestamp) + " " + msg.GetFrom() + " " +
msg.GetTo() + " " + msg.GetText() + "\n";
}
return response;
}
else if (command == "SEND")
{
std::string recipient, text;
iss >> recipient;
std::getline(iss, text);
if (clientToUser_.count(clientSocket) == 0)
return "ERROR\nNot logged in";
if (recipient != "всем" && usersByName_.count(recipient) == 0)
return "ERROR\nRecipient not found";
std::string sender = clientToUser_[clientSocket];
messages_.emplace_back(sender, recipient, text);
return "OK\nMessage sent";
}
else if (command == "GET_USERS")
{
std::string response = "USER_LIST\n";
for (const auto &pair : usersByName_)
{
response += pair.first + "\n";
}
return response;
}
return "ERROR\nUnknown command";
}
void Server::handleDisconnect(SocketType clientSocket)
{
std::lock_guard<std::mutex> lock(dataMutex_);
clientToUser_.erase(clientSocket);
}
}
int main()
{
#if defined(_WIN32)
SetConsoleOutputCP(65001);
#endif
try
{
NetApp::Server server(8080);
server.start();
std::cout << "Нажмите Enter для остановки сервера...\n";
std::cin.get();
server.stop();
}
catch (const std::exception &ex)
{
std::cerr << "Исключение: " << ex.what() << std::endl;
return 1;
}
return 0;
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\networking\netApp\NetApp.h -----
#pragma once
#include <string>
#include <vector>
#include <thread>
#include <atomic>
#include <mutex>
#include <unordered_map>
#include <memory>
#include <sstream>
#include "../chatApp/ChatApp.h"
#if defined(_WIN32)
#include <winsock2.h>
#include <ws2tcpip.h>
typedef SOCKET SocketType;
const SocketType INVALID_SOCKET_VALUE = INVALID_SOCKET;
const int SOCKET_ERROR_VALUE = SOCKET_ERROR;
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
typedef int SocketType;
const SocketType INVALID_SOCKET_VALUE = -1;
const int SOCKET_ERROR_VALUE = -1;
#endif
namespace NetApp
{
class Server
{
private:
unsigned short port_;
SocketType serverSocket_;
std::atomic<bool> running_;
std::vector<std::thread> clientThreads_;
std::mutex dataMutex_;
std::unordered_map<std::string, std::shared_ptr<ChatApp::User>> usersByLogin_;
std::unordered_map<std::string, std::shared_ptr<ChatApp::User>> usersByName_;
std::vector<ChatApp::Message> messages_;
std::unordered_map<SocketType, std::string> clientToUser_;
public:
Server(unsigned short port);
~Server();
bool start();
void stop();
void acceptClients();
void handleClient(SocketType clientSocket);
std::string processRequest(SocketType clientSocket, const std::string &request);
private:
void handleDisconnect(SocketType clientSocket);
};
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\networking\utils\messages.h -----
#pragma once
namespace serverMessages
{
constexpr const char *WSASTARTUP_ERROR = "WSAStartup не удалась: ";
constexpr const char *SERVER_SOCKET_ERROR = "Ошибка создания серверного сокета.";
constexpr const char *BIND_ERROR = "Ошибка привязки сокета к порту ";
constexpr const char *LISTEN_ERROR = "Ошибка прослушивания сокета.";
constexpr const char *SERVER_STARTED = "Сервер запущен на порту ";
constexpr const char *CLIENT_ACCEPT_ERROR = "Ошибка приема клиента.";
constexpr const char *NEW_CLIENT_CONNECTED = "Новый клиент подключился: ";
constexpr const char *CLIENT_DISCONNECTED = "Клиент отключился.";
constexpr const char *SEND_ERROR = "Ошибка отправки данных клиенту.";
constexpr const char *RECEIVE_ERROR = "Ошибка приема данных от клиента.";
constexpr const char *SERVER_STOPPED = "Сервер остановлен.";
}
namespace clientMessages
{
constexpr const char *WSASTARTUP_ERROR = "WSAStartup не удалась: ";
constexpr const char *CLIENT_SOCKET_ERROR = "Ошибка создания клиентского сокета.";
constexpr const char *INVALID_ADDRESS = "Некорректный адрес или адрес не поддерживается.";
constexpr const char *CONNECT_ERROR = "Ошибка подключения к серверу.";
constexpr const char *CONNECT_SUCCESS = "Подключение к серверу ";
constexpr const char *DISCONNECT_SUCCESS = "Отключение от сервера выполнено.";
constexpr const char *SEND_ERROR = "Ошибка отправки сообщения.";
constexpr const char *RECEIVE_ERROR = "Ошибка приёма данных.";
constexpr const char *SERVER_CLOSED = "Сервер закрыл соединение.";
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\networking\utils\NetworkInitializer.h -----
#pragma once
#include <stdexcept>
#if defined(_WIN32)
#include <winsock2.h>
#include <ws2tcpip.h>
#endif
class NetworkInitializer
{
public:
NetworkInitializer()
{
#if defined(_WIN32)
WSADATA wsaData;
int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
if (result != 0)
{
throw std::runtime_error("WSAStartup failed with error: " + std::to_string(result));
}
#endif
}
~NetworkInitializer()
{
#if defined(_WIN32)
WSACleanup();
#endif
}
};
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\networking\utils\SocketHandler.h -----
#pragma once
#include <stdexcept>
#if defined(_WIN32)
#include <winsock2.h>
typedef SOCKET SocketType;
#define INVALID_SOCKET_VALUE INVALID_SOCKET
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
typedef int SocketType;
#define INVALID_SOCKET_VALUE (-1)
#define SOCKET_ERROR (-1)
#endif
class SocketHandler
{
public:
explicit SocketHandler(SocketType sock = INVALID_SOCKET_VALUE) : socket_(sock) {}
~SocketHandler() { closeSocket(); }
SocketType get() const { return socket_; }
void reset(SocketType sock = INVALID_SOCKET_VALUE)
{
closeSocket();
socket_ = sock;
}
void closeSocket()
{
if (socket_ != INVALID_SOCKET_VALUE)
{
#if defined(_WIN32)
closesocket(socket_);
#else
close(socket_);
#endif
socket_ = INVALID_SOCKET_VALUE;
}
}
private:
SocketType socket_;
};
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\Chat\Chat.cpp -----
#include "Chat.h"
#include <iostream>
#include <limits>
#include <sstream>
namespace ChatApp
{
Chat::Chat(const std::string &serverAddress, unsigned short serverPort)
: client_(serverAddress, serverPort, this)
{
client_.connectToServer();
client_.startReceiving();
}
void Chat::Start()
{
_isActive = true;
}
void Chat::login()
{
if (_currentUser != nullptr)
{
std::cout << "Вы уже вошли в систему.\n";
return;
}
std::string login, password;
std::cout << "Логин: ";
std::cin >> login;
std::cout << "Пароль: ";
std::cin >> password;
std::string request = "LOGIN " + login + " " + password;
try
{
if (!client_.sendMessage(request))
{
std::cerr << "Ошибка отправки запроса на вход\n";
}
}
catch (const std::exception &ex)
{
std::cerr << "Исключение при отправке запроса на вход: " << ex.what() << std::endl;
}
}
void Chat::signUp()
{
std::string login, password, name;
std::cout << "Придумайте логин: ";
std::cin >> login;
std::cout << "Придумайте пароль: ";
std::cin >> password;
std::cout << "Ваше имя: ";
std::cin >> name;
std::string request = "SIGNUP " + login + " " + password + " " + name;
try
{
if (!client_.sendMessage(request))
{
std::cerr << "Ошибка отправки запроса на регистрацию\n";
}
}
catch (const std::exception &ex)
{
std::cerr << "Исключение при отправке запроса на регистрацию: " << ex.what() << std::endl;
}
}
void Chat::displayChat()
{
try
{
if (!client_.sendMessage("GET_CHAT"))
{
std::cerr << "Ошибка запроса чата\n";
}
}
catch (const std::exception &ex)
{
std::cerr << "Исключение при запросе чата: " << ex.what() << std::endl;
}
}
void Chat::displayAllUserNames()
{
try
{
if (!client_.sendMessage("GET_USERS"))
{
std::cerr << "Ошибка запроса списка пользователей\n";
}
}
catch (const std::exception &ex)
{
std::cerr << "Исключение при запросе списка пользователей: " << ex.what() << std::endl;
}
}
void Chat::addMessage()
{
std::string recipient, text;
std::cout << "Введите имя получателя или 'всем': ";
std::cin >> recipient;
std::cout << "Текст сообщения: ";
std::cin.ignore();
std::getline(std::cin, text);
std::string request = "SEND " + recipient + " " + text;
try
{
if (!client_.sendMessage(request))
{
std::cerr << "Ошибка отправки сообщения\n";
return;
}
std::cout << "Сообщение отправлено\n";
}
catch (const std::exception &ex)
{
std::cerr << "Исключение при отправке сообщения: " << ex.what() << std::endl;
}
}
void Chat::displayLoginMenu()
{
while (_currentUser == nullptr && _isActive)
{
std::cout << "\n--- Меню входа ---\n";
std::cout << "1. Вход\n";
std::cout << "2. Регистрация\n";
std::cout << "3. Выход\n";
std::cout << "Выберите опцию: ";
int choice;
while (!(std::cin >> choice))
{
std::cin.clear();
std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
std::cout << "Неверный ввод. Попробуйте снова: ";
}
switch (choice)
{
case 1:
login();
break;
case 2:
signUp();
break;
case 3:
std::cout << "Выход из приложения.\n";
_isActive = false;
return;
default:
std::cout << "Неверный выбор. Попробуйте снова.\n";
}
}
}
void Chat::displayUserMenu()
{
while (_isActive && _currentUser != nullptr)
{
std::cout << "\n--- Меню пользователя ---\n";
std::cout << "1. Просмотр чата\n";
std::cout << "2. Отправить сообщение\n";
std::cout << "3. Выход\n";
std::cout << "Выберите опцию: ";
int choice;
while (!(std::cin >> choice))
{
std::cin.clear();
std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
std::cout << "Неверный ввод. Попробуйте снова: ";
}
switch (choice)
{
case 1:
displayChat();
break;
case 2:
addMessage();
break;
case 3:
std::cout << "Выход из аккаунта.\n";
_currentUser = nullptr;
return;
default:
std::cout << "Неверный выбор. Попробуйте снова.\n";
}
}
}
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\Chat\Chat.h -----
#pragma once
#include <string>
#include <memory>
#include "../Message/Message.h"
#include "../User/User.h"
#include "../../networking/client/Client.h"
namespace ChatApp
{
class Chat
{
private:
bool _isActive = false;
std::shared_ptr<User> _currentUser = nullptr;
NetApp::Client client_;
void login();
void signUp();
void displayChat();
void displayAllUserNames();
void addMessage();
public:
Chat(const std::string &serverAddress, unsigned short serverPort);
~Chat() = default;
void Start();
bool ChatIsActive() const { return _isActive; }
std::shared_ptr<User> GetCurrentUser() const { return _currentUser; }
void setCurrentUser(const std::shared_ptr<User> &user) { _currentUser = user; }
void displayLoginMenu();
void displayUserMenu();
};
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\Chat\utils\Display.cpp -----
#include "Display.h"
#include <iostream>
#include <iomanip>
#include <ctime>
namespace ChatApp
{
namespace DisplayUtils
{
void PrintSeparator(const std::string &title)
{
if (!title.empty())
{
std::cout << "\n--- " << title << " ---\n";
}
else
{
std::cout << "\n---------------------\n";
}
}
void PrintMessage(const std::string &from, const std::string &to,
const std::string &text, const std::string &timestamp)
{
try
{
std::time_t ts = std::stoll(timestamp);
std::tm *tm_info = std::localtime(&ts);
char buffer[80];
std::strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);
std::cout << "Время: " << buffer << "\n";
}
catch (...)
{
std::cout << "Время: " << timestamp << "\n";
}
std::cout << "Сообщение от " << from << " для " << to << ":\n"
<< text << "\n\n";
}
}
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\Chat\utils\Display.h -----
#pragma once
#include <string>
namespace ChatApp
{
namespace DisplayUtils
{
void PrintSeparator(const std::string &title = "");
void PrintMessage(const std::string &from, const std::string &to,
const std::string &text, const std::string &timestamp);
}
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\Chat\utils\Exceptions.h -----
#pragma once
#include <exception>
namespace ChatApp
{
class UserLoginException : public std::exception
{
public:
const char *what() const noexcept override
{
return "Ошибка: логин пользователя занят.";
}
};
class UserNameException : public std::exception
{
public:
const char *what() const noexcept override
{
return "Ошибка: имя пользователя занято.";
}
};
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\Chat\utils\Input.cpp -----
#include <limits>
#include "Input.h"
namespace ChatApp
{
namespace InputUtils
{
char ReadOption()
{
char option;
std::cin >> option;
std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
return option;
}
std::string ReadLine()
{
std::string line;
std::getline(std::cin, line);
return line;
}
}
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\Chat\utils\Input.h -----
#pragma once
#include <string>
#include <iostream>
namespace ChatApp
{
namespace InputUtils
{
char ReadOption();
std::string ReadLine();
}
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\Chat\utils\Time.cpp -----
#include "Time.h"
#include <sstream>
#include <iomanip>
#include <ctime>
namespace ChatApp
{
namespace TimeUtils
{
std::string FormatTimestamp(const std::chrono::system_clock::time_point &tp)
{
std::time_t time = std::chrono::system_clock::to_time_t(tp);
std::tm tm;
#ifdef _WIN32
localtime_s(&tm, &time);
#else
localtime_r(&time, &tm);
#endif
std::ostringstream oss;
oss << std::put_time(&tm, "%Y-%m-%d %H:%M:%S");
return oss.str();
}
}
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\Chat\utils\Time.h -----
#pragma once
#include <string>
#include <chrono>
namespace ChatApp
{
namespace TimeUtils
{
std::string FormatTimestamp(const std::chrono::system_clock::time_point &tp);
}
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\Message\Message.cpp -----
#include "Message.h"
namespace ChatApp
{
Message::Message(const std::string &from, const std::string &to, const std::string &text)
: _from(from), _to(to), _text(text), _timestamp(std::chrono::system_clock::now()) {}
const std::string &Message::GetFrom() const
{
return _from;
}
const std::string &Message::GetTo() const
{
return _to;
}
const std::string &Message::GetText() const
{
return _text;
}
std::chrono::system_clock::time_point Message::GetTimestamp() const
{
return _timestamp;
}
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\Message\Message.h -----
#pragma once
#include <string>
#include <chrono>
namespace ChatApp
{
class Message
{
private:
std::string _from;
std::string _to;
std::string _text;
std::chrono::system_clock::time_point _timestamp;
public:
Message(const std::string &from, const std::string &to, const std::string &text);
const std::string &GetFrom() const;
const std::string &GetTo() const;
const std::string &GetText() const;
std::chrono::system_clock::time_point GetTimestamp() const;
};
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\User\User.cpp -----
#include "User.h"
namespace ChatApp
{
User::User(const std::string &login, const std::string &password, const std::string &name)
: _login(login), _password(password), _name(name) {}
const std::string &User::GetUserLogin() const
{
return _login;
}
const std::string &User::GetUserPassword() const
{
return _password;
}
const std::string &User::GetUserName() const
{
return _name;
}
void User::SetUserPassword(const std::string &password)
{
_password = password;
}
void User::SetUserName(const std::string &name)
{
_name = name;
}
}
----- Файл: P:\1.From Git\SkillfactoryCpp\Console chat\app\src\User\User.h -----
#pragma once
#include <string>
namespace ChatApp
{
class User
{
private:
const std::string _login;
std::string _password;
std::string _name;
public:
User(const std::string &login, const std::string &password,
const std::string &name);
const std::string &GetUserLogin() const;
const std::string &GetUserPassword() const;
const std::string &GetUserName() const;
void SetUserPassword(const std::string &password);
void SetUserName(const std::string &name);
};
}
create extension if not exists pgcrypto;
create table users
(
user_id       serial primary key,
login         varchar(50) unique not null,
password_hash varchar(512)       not null,
name          varchar(100)       not null,
created_at    timestamp default current_timestamp,
update_at     timestamp default current_timestamp,
salt          varchar(255)
);
create table chats
(
chat_id     serial primary key,
chat_type   varchar(10) not null check (chat_type in ('личный', 'групповой')),
chat_name   varchar(100),
description text,
created_at  timestamp default current_timestamp
);
create table chat_participants
(
chat_id   int not null,
user_id   int not null,
joined_at timestamp default current_timestamp,
primary key (chat_id, user_id),
foreign key (chat_id) references chats (chat_id),
foreign key (user_id) references users (user_id)
);
create table messages
(
message_id   serial primary key,
chat_id      int  not null,
sender_id    int  not null,
message_text text not null,
sent_at      timestamp default current_timestamp,
edited       boolean   default false,
foreign key (chat_id) references chats (chat_id),
foreign key (sender_id) references users (user_id)
);
create table message_recipients
(
message_id   int         not null,
recipient_id int         not null,
status       varchar(20) not null check (status in ('отправлено', 'доставлено', 'прочитано')),
primary key (message_id, recipient_id),
foreign key (message_id) references messages (message_id),
foreign key (recipient_id) references users (user_id)
);
create table user_roles
(
role_id     serial primary key,
role_name   varchar(50) unique not null,
description text,
priority    int
);
create table chat_roles
(
chat_id int not null,
user_id int not null,
role_id int not null,
primary key (chat_id, user_id, role_id),
foreign key (chat_id) references chats (chat_id),
foreign key (user_id) references users (user_id),
foreign key (role_id) references user_roles (role_id)
);
create table attachments
(
attachment_id serial primary key,
message_id    int          not null,
file_path     varchar(255) not null,
file_type     varchar(50)  not null,
file_size     int,
uploaded_at   timestamp default current_timestamp,
foreign key (message_id) references messages (message_id),
constraint check_file_size check (file_size >= 0)
);
create table message_logs
(
log_id       serial primary key,
message_id   int not null,
recipient_id int references users (user_id),
old_text     text,
new_text     text,
old_status   varchar(20),
new_status   varchar(20),
changed_at   timestamp default current_timestamp
);
create index idx_user_login on users (login);
create index idx_messages_sent_at on messages (sent_at);
create index idx_messages_chat_id on messages (chat_id);
create index idx_chat_participants_user_id on chat_participants (user_id);
create index idx_message_recipients_message_id on message_recipients (message_id);
create or replace function register_user(
p_login varchar,
p_password varchar,
p_name varchar
)
returns void as
$$
declare
v_salt          varchar(255);
v_password_hash varchar(512);
begin
if exists(select 1 from users where login = p_login) then
raise exception 'Логин уже существует: %', p_login;
end if;
v_salt := gen_salt('bf');
v_password_hash := crypt(p_password, v_salt);
insert into users (login, password_hash, name, salt)
values (p_login, v_password_hash, p_name, v_salt);
end;
$$ language plpgsql;
create or replace procedure send_message(
p_chat_id int,
p_sender_id int,
p_message_text text,
p_recipient_ids int[]
)
language plpgsql
as
$$
declare
v_message_id int;
recipient    int;
begin
if not exists (select 1
from chat_participants
where chat_id = p_chat_id
and user_id = p_sender_id) then
raise exception 'Отправитель % не является участником чата %', p_sender_id, p_chat_id;
end if;
foreach recipient in array p_recipient_ids
loop
if not exists (select 1
from chat_participants
where chat_id = p_chat_id
and user_id = recipient) then
raise exception 'Получатель % не является участником чата %', recipient, p_chat_id;
end if;
end loop;
insert into messages (chat_id, sender_id, message_text)
values (p_chat_id, p_sender_id, p_message_text)
returning message_id into v_message_id;
foreach recipient in array p_recipient_ids
loop
insert into message_recipients (message_id, recipient_id, status)
values (v_message_id, recipient, 'отправлено');
end loop;
end;
$$;
create or replace function update_updated_at_column()
returns trigger as
$$
begin
new.update_at = current_timestamp;
return new;
end;
$$ language plpgsql;
create trigger update_users_updated_at
before update
on users
for each row
execute function update_updated_at_column();
create or replace function log_messages_changes()
returns trigger as
$$
begin
insert into message_logs (message_id, old_text, new_text, changed_at)
values (old.message_id, old.message_text, new.message_text, current_timestamp);
return new;
end;
$$ language plpgsql;
create trigger log_messages_changes
after update
on messages
for each row
when (old.message_text is distinct from new.message_text)
execute function log_messages_changes();
create or replace function log_message_recipients_changes()
returns trigger as
$$
begin
insert into message_logs (message_id, recipient_id, old_status, new_status, changed_at)
values (old.message_id, old.recipient_id, old.status, new.status, current_timestamp);
return new;
end;
$$ language plpgsql;
create trigger log_message_recipients_changes
after update
on message_recipients
for each row
when (old.status is distinct from new.status)
execute function log_message_recipients_changes();
