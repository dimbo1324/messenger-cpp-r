<!-- 
TODO: Ссылка на ТЗ (Database for console chat's project): 
* https://docs.google.com/document/d/1gSBqZ10cYyHCSCBy8xABeF39an_JUxmv0StW5y-0UvE/edit?usp=sharing 
-->

<!-- 
Техническое задание на разработку базы данных проекта «Чат»
1. Общие положения
База данных должна обеспечивать:
Нормализацию до 4-й нормальной формы, что исключает транзитивные и многозначные зависимости.
Блочность и динамичность за счёт использования автоинкрементных ключей и триггеров для автоматической синхронизации данных.
Безопасность за счёт разделения публичных и конфиденциальных данных (разделение таблиц с профилем и учетными данными, применение современных методов хэширования с солью).
Масштабируемость посредством индексирования ключевых полей и возможного партиционирования крупных таблиц (например, сообщений) по временным периодам.
Интегрируемость и читаемость благодаря четкой документированной структуре таблиц и явному определению связей.
Поддерживаемость за счёт ведения аудита (таблица audit_log) и автоматизации (триггеры для создания/удаления записей в связанных таблицах).
2. Структура базы данных
2.1 Таблица: users_profile
Поля и их характеристики:
user_id
Тип: Автоинкрементное целое число (SERIAL/INTEGER).
Описание: Уникальный идентификатор пользователя, служащий первичным ключом.
Роль и обоснование: Обеспечивает уникальность каждой записи и используется для связей с другими таблицами.
first_name
Тип: VARCHAR(50).
Описание: Имя пользователя для отображения в интерфейсе.
Роль и обоснование: Используется для персонализации и идентификации пользователя.
last_name
Тип: VARCHAR(50).
Описание: Фамилия пользователя для отображения в интерфейсе.
Роль и обоснование: Совместно с именем помогает однозначно идентифицировать пользователя.
email
Тип: VARCHAR(100) (с уникальным ограничением).
Описание: Уникальный адрес электронной почты, используемый для входа и связи.
Роль и обоснование: Является важным идентификатором и коммуникационным каналом; уникальность предотвращает дублирование.
language
Тип: VARCHAR(10) или ENUM (при ограниченном наборе языков).
Описание: Предпочитаемый язык пользователя для локализации интерфейса.
Роль и обоснование: Обеспечивает поддержку многоязычного интерфейса и персонализацию.
timezone
Тип: VARCHAR(50) или ссылка на справочную таблицу часовых поясов.
Описание: Часовой пояс пользователя для корректного отображения времени в системе.
Роль и обоснование: Позволяет корректно синхронизировать время для пользователей из разных регионов.
created_at
Тип: TIMESTAMP (с дефолтным значением – текущее время).
Описание: Время создания записи пользователя.
Роль и обоснование: Используется для аудита, отслеживания регистрации и истории изменений.
updated_at
Тип: TIMESTAMP (с дефолтным значением – текущее время, обновляется автоматически).
Описание: Время последнего обновления записи.
Роль и обоснование: Помогает отслеживать изменения и обеспечивает актуальность данных.
is_deleted
Тип: BOOLEAN (по умолчанию FALSE).
Описание: Флаг логического удаления записи пользователя.
Роль и обоснование: Обеспечивает возможность мягкого удаления данных для сохранения истории и последующего восстановления.
2.2 Таблица: users_credentials
Поля и их характеристики:
user_id
Тип: INTEGER.
Описание: Идентификатор пользователя, являющийся первичным ключом и внешним ключом, ссылающимся на users_profile.user_id.
Роль и обоснование: Связывает учетные данные с публичной информацией пользователя; использование одного и того же идентификатора повышает безопасность и целостность данных (отношение 1:1).
password_hash
Тип: VARCHAR(255).
Описание: Хэшированное значение пароля пользователя.
Роль и обоснование: Гарантирует безопасность аутентификации, так как реальный пароль не хранится в открытом виде.
salt
Тип: VARCHAR(50).
Описание: Случайная строка, применяемая при хэшировании пароля для усиления защиты от атак.
Роль и обоснование: Повышает стойкость хэширования и предотвращает использование предварительно вычисленных таблиц (rainbow tables).
Примечание по автоматизации:
При добавлении новой записи в таблицу users_profile срабатывает триггер, который автоматически создает соответствующую запись в users_credentials с тем же user_id и значением password_hash = NULL. Аналогичным образом, при удалении записи из users_profile удаляется связанная запись в users_credentials.
2.3 Таблица: messages
Поля и их характеристики:
message_id
Тип: Автоинкрементное целое число (SERIAL/INTEGER).
Описание: Уникальный идентификатор сообщения, являющийся первичным ключом.
Роль и обоснование: Обеспечивает уникальную идентификацию каждого сообщения в системе.
sender_id
Тип: INTEGER.
Описание: Идентификатор отправителя сообщения, внешний ключ, ссылающийся на users_profile.user_id.
Роль и обоснование: Обеспечивает связь между сообщениями и пользователем-отправителем (отношение один ко многим).
receiver_id
Тип: INTEGER.
Описание: Идентификатор получателя сообщения, внешний ключ, ссылающийся на users_profile.user_id.
Роль и обоснование: Обеспечивает связь между сообщениями и пользователем-получателем (отношение один ко многим).
text
Тип: VARCHAR(1000) или TEXT.
Описание: Текстовое содержимое сообщения.
Роль и обоснование: Основной контент сообщения, необходимый для коммуникации между пользователями.
message_type
Тип: VARCHAR(20) или ENUM (например, 'text', 'image', 'file').
Описание: Тип сообщения, определяющий формат содержимого (например, текст, изображение, файл).
Роль и обоснование: Позволяет системе различать типы сообщений и правильно обрабатывать их отображение и логику.
sent_at
Тип: TIMESTAMP (с дефолтным значением – текущее время).
Описание: Дата и время отправки сообщения.
Роль и обоснование: Обеспечивает хронологическую последовательность переписки, что важно для истории общения.
status
Тип: INTEGER.
Описание: Код статуса сообщения (например, 0 – не доставлено, 1 – доставлено, 2 – прочитано).
Роль и обоснование: Позволяет отслеживать этапы доставки и прочтения сообщения, что важно для обеспечения обратной связи между пользователями. Рекомендуется добавить CHECK-констрейнт для допустимых значений.
2.4 Таблица: message_attachments
Поля и их характеристики:
attachment_id
Тип: Автоинкрементное целое число (SERIAL/INTEGER).
Описание: Уникальный идентификатор вложения, являющийся первичным ключом.
Роль и обоснование: Обеспечивает уникальную идентификацию каждого файла-вложения.
message_id
Тип: INTEGER.
Описание: Идентификатор сообщения, к которому прикреплено вложение, внешний ключ, ссылающийся на messages.message_id.
Роль и обоснование: Обеспечивает связь между сообщением и его вложениями (отношение один ко многим).
file_path
Тип: VARCHAR(255).
Описание: Путь к файлу вложения в файловой системе или облачном хранилище.
Роль и обоснование: Позволяет системе находить и извлекать вложения для отображения пользователю.
file_type
Тип: VARCHAR(50) или ENUM (например, 'image/jpeg', 'application/pdf').
Описание: Тип файла вложения, позволяющий корректно обрабатывать и отображать данные.
Роль и обоснование: Обеспечивает адаптивную обработку различных форматов файлов.
2.5 Таблица: audit_log
Поля и их характеристики:
log_id
Тип: Автоинкрементное целое число (SERIAL/INTEGER).
Описание: Уникальный идентификатор записи аудита, являющийся первичным ключом.
Роль и обоснование: Позволяет однозначно идентифицировать каждую запись аудита.
table_name
Тип: VARCHAR(50).
Описание: Название таблицы, в которой произошло изменение.
Роль и обоснование: Обеспечивает контекст для каждой аудиторской записи.
record_id
Тип: INTEGER.
Описание: Идентификатор изменённой записи в соответствующей таблице.
Роль и обоснование: Позволяет точно определить, какая запись была изменена.
action
Тип: VARCHAR(20) или ENUM (например, 'INSERT', 'UPDATE', 'DELETE').
Описание: Тип выполненного действия.
Роль и обоснование: Обеспечивает понимание характера изменений для последующего анализа.
changed_at
Тип: TIMESTAMP (с дефолтным значением – текущее время).
Описание: Дата и время выполнения изменения.
Роль и обоснование: Позволяет восстановить последовательность событий и проводить аудит.
changed_by
Тип: INTEGER.
Описание: Идентификатор пользователя, инициировавшего изменение, внешний ключ, ссылающийся на users_profile.user_id.
Роль и обоснование: Позволяет установить ответственность за внесенные изменения.
old_data
Тип: JSON.
Описание: Снимок данных до изменения.
Роль и обоснование: Обеспечивает возможность восстановления данных и анализа внесенных изменений.
new_data
Тип: JSON.
Описание: Снимок данных после изменения.
Роль и обоснование: Позволяет сравнить состояние до и после изменений, что полезно для аудита.
3. Взаимосвязи между таблицами и обоснование
Связь между таблицами users_profile и users_credentials:
Тип связи: Один к одному.
Обоснование: Каждый пользователь имеет один набор учетных данных. Разделение публичной информации и конфиденциальных данных повышает безопасность, позволяя ограничить доступ к таблице с паролями.
Связь между таблицами users_profile и messages (как отправитель и получатель):
Тип связи: Один ко многим.
Обоснование: Один пользователь может отправлять множество сообщений (поле sender_id) и получать их (поле receiver_id), что обеспечивает хранение полной истории переписки и удобный поиск по участникам.
Связь между таблицами messages и message_attachments:
Тип связи: Один ко многим.
Обоснование: Одно сообщение может содержать несколько вложений. Разделение текстовой информации и вложений облегчает управление данными и позволяет масштабировать таблицу сообщений без перегрузки дополнительными данными.
Связь аудита через таблицу audit_log:
Тип связи: Логически – многие ко многим (реализуется через идентификаторы записей в различных таблицах).
Обоснование: Каждое изменение в основных таблицах фиксируется в журнале аудита с указанием названия таблицы и идентификатора измененной записи. Это обеспечивает полную прослеживаемость и возможность восстановления данных, а также позволяет анализировать изменения и устанавливать ответственность.
Дополнительно:
При добавлении и удалении пользователя должны использоваться триггеры для автоматической синхронизации данных между таблицами users_profile и users_credentials (автоматическое создание записи с password_hash = NULL при добавлении, каскадное или логическое удаление при удалении).
Рекомендуется использовать каскадное обновление/удаление там, где это уместно, либо логическое удаление (через флаг is_deleted) для сохранения истории.
4. Итоговое обоснование архитектуры
Нормализация (до 4-й нормальной формы):
Каждая таблица содержит только атомарные значения, отсутствуют избыточные данные. Все неключевые атрибуты зависят исключительно от первичных ключей, что исключает транзитивные и многозначные зависимости.
Блочность и динамичность:
Использование автоинкрементных ключей и триггеров позволяет автоматизировать синхронизацию данных между таблицами, поддерживать целостность данных и динамично реагировать на изменения (например, автоматическое обновление поля updated_at).
Безопасность:
Разделение публичных данных (таблица users_profile) и конфиденциальных данных (таблица users_credentials) повышает уровень защиты. Применение современных методов хэширования с солью обеспечивает безопасность аутентификации, а ограничение доступа к таблице с учетными данными снижает риски.
Масштабируемость:
Возможность индексирования ключевых полей (например, email, sender_id, receiver_id, sent_at) и потенциальное партиционирование таблицы messages по времени гарантирует высокую производительность даже при большом объеме данных.
Интегрируемость и читаемость:
Четкая, документированная структура таблиц, использование стандартных типов данных и явное определение связей упрощают интеграцию с внешними системами и повышают читаемость базы данных.
Поддерживаемость:
Наличие журнала аудита (audit_log) позволяет отслеживать изменения, что упрощает диагностику проблем и восстановление данных. Автоматизация посредством триггеров снижает вероятность ошибок при ручном управлении данными.
Эта архитектура соответствует мировым стандартам 2025 года и готова к расширению в будущем (например, для поддержки групповых чатов, ролей пользователей, дополнительных типов сообщений и вложений), обеспечивая надежную, масштабируемую и безопасную систему для работы с данными проекта чата.
Разработка должна учитывать возможность внедрения дополнительных проверок (например, CHECK-констрейнтов для полей status и message_type), а также предусмотреть индексацию наиболее часто используемых полей для повышения производительности системы. 
-->
